// {{Depend : Akari}} //

/* Namespace: Akari.Utilities
 * Provide utilities not directly related to presenting content.
 */
Akari.Utilities = {};

/* Static Class: Factory
 * Provides functions for creating and manipulating objects.
 * Legacy name used because this was once an actual factory. (See : 2012/11/21 Update)
 */
Akari.Utilities.Factory =
{
  /* Function: collapse
   * Concats all arrays given into one.
   *
   * arrays
   *   An Array of Arrays.
   */
  collapse : function( arrays )
  {
    var result = [];
    
    for ( var i = 0; i < arrays.length; i ++ )
    {
      result = result.concat( arrays[ i ] );
    }
    
    return result;
  },
  
  /* Function: extend
   * Copies all properties from the source to the destination object.
   *
   * destination
   *   Destination object.
   * source
   *   Source object.
   */
  extend : function( destination, source )
  {
    // Iterate through the source
    foreach ( source, function( key, object )
    {
      destination[ key.toString() ] = object;
    });
    
    return destination;
  },
  
  /* Function: clone
   * Clones an Object.
   *
   * object
   *   The Object to clone.
   */
  clone : function( object, scope )
  {
    // It just might happen to be nothing.
    if ( ! object )
    {
      return object;
    }

    // Check if the object contains a custom clone function for cloning private variables.
    if ( object.hasOwnProperty( "clone" ) )
    {
      return object.clone();
    }
    else if ( typeof object === "function" )
    {
      return function() { return object.apply( scope, arguments ); };
    }
    else
    {
      // Iterate through the Object running this clone function
      var newObject = {};
      var countProperties = 0;

      foreach ( object, function( key, object )
      {
        countProperties ++;
        
        if ( typeof object === "function" )
        {
          newObject[ key ] = function() { return object.apply( newObject, arguments ); };
        }
        else
        {
          var adg = Akari.Utilities.Factory.clone( object );
          newObject[ key ] = adg;
        }
      });
      
      // Check if newObject is empty
      if ( countProperties === 0 )
      {
        // Probably AS3 or an empty shit, make a clone first
        newObject = clone( object );

        if ( object.hasOwnProperty( "numChildren" ) || object.hasOwnProperty( "graphics" ) )
        {
          newObject = $.createCanvas(
          {
            lifeTime : 810114514
          });

          ScriptManager.popEl( newObject );

          // copy some displayObject parameters
          newObject.alpha = object.alpha;
          newObject.blendMode = object.blendMode;
          newObject.filters = object.filters;
          newObject.rotationX = object.rotationX;
          newObject.rotationY = object.rotationY;
          newObject.rotationZ = object.rotationZ;
          newObject.scaleX = object.scaleX;
          newObject.scaleY = object.scaleY;
          newObject.scaleZ = object.scaleZ;
          newObject.scrollRect = object.scrollRect;
          newObject.transform.colorTransform = object.transform.colorTransform;
          newObject.transform.matrix = object.transform.matrix;
          newObject.transform.matrix3D = object.transform.matrix3D;
        }
        
        // Check if it's a DOC
        if ( object.hasOwnProperty( "numChildren" ) )
        {
          for ( var i = 0; i < object.numChildren; i ++ )
          {
            newObject.addChild( Akari.Utilities.Factory.clone( object.getChildAt( i ) ) );
          }
        }
        
        // Check if it's a Shape
        if ( object.hasOwnProperty( "graphics" ) )
        {
          // Clone the Graphic's content
          newObject.graphics.copyFrom( object.graphics );
        }
      }
      
      return newObject;
    }
  },
  
  /* Function: replicate
   * Returns an Array of Objects created according to given params. 
   *
   * constructor
   *   Constructor of the Class to replicate.
   * count
   *   Count of result Objects.
   * paramsFunction
   *   A Function accepting index as parameter, returning an Array of parameters.
   */
  replicate : function( constructor, count, paramsFunction )
  {
    var objects = [];
    
    var i = 0;
    for ( i = 0; i < count; i ++ )
    {
      var newParams;
      
      newParams = paramsFunction ? paramsFunction( i ) : [];
      
      objects.push( constructor.apply( this, newParams ) );
    }
    
    return objects;
  }
};

/* Static Class: Timer
 * Improves timing precision over Player.time by sampling time usage for each frame. For retaining both smoothness and seekability.
 */
Akari.Utilities.Timer = function()
{
  var lastTime = 0;
  var deltaTime = 0;
  var sampleCount = 1;
  
  return
  {
    time : 0,
    
    /* Function: update
     * Counts a frame and updates time.
     */
    update : function()
    {
      if ( Player.time != lastTime )
      {
        // Make drastic change proof
        if ( Math.abs( Player.time - lastTime ) < 1000 )
        {
          deltaTime = ( Player.time - lastTime ) / sampleCount;
          lastTime = Player.time;
          sampleCount = 1;
          
          this.time = Player.time;
        }
        else
        {
          // Reset Timer because of a possible seek (or just so laggy that Timer is not effective)
          deltaTime = 0;
          lastTime = Player.time;
          sampleCount = 1;
          
          this.time = Player.time;
        }
      }
      else
      {
        this.time = lastTime + deltaTime * sampleCount;
        sampleCount ++;
      }
    }
  };
}();

/* Class: Binder
 * Provides functions for binding properties. Mainly used in layers.
 *
 * object
 *   An Object to bind.
 * properties
 *   An Object, containing values or Bindings for each property.
 * overridePathCheck
 *   [default] false
 *   Specifying this will override path checking, so that new properties can be added to the object.
 *   It is impossible to add new properties on AS3 objects (Error #1056), hence the protective mechanism. Override only if the feature is needed.
 */
Akari.Utilities.Binder = function()
{
  var binderClass = function( params )
  {
    var registry = [];
    var lookup = {};
    var needRefresh = true;

    var setParam = function( object, name, value )
    {
      var dotIndex = name.indexOf(".");
      if ( dotIndex < 0 )
      {
        if ( params.overridePathCheck || object.hasOwnProperty( name ) )
        {
          object[ name ] = value;
        }
      }
      else
      {
        var midName = name.substring( 0, dotIndex );
        if ( params.overridePathCheck )
        {
          if ( !object.hasOwnProperty( midName ) )
          {
            object[ midName ] = {};
          }
          setParam( object[ midName ], name.substring( dotIndex + 1 ), value );
        }
        else
        {
          if ( object.hasOwnProperty( midName ) )
          {
            setParam( object[ midName ], name.substring( dotIndex + 1 ), value );
          }
        }
      }
    };
    
    foreach( params.properties, function( key, obj )
    {
      var changeType = null;
      var value = null;

      if ( typeof( obj ) === "function" )
      {
        changeType = "func";
      }
      else if ( obj.hasOwnProperty( "linkFunc" ) )
      {
        changeType = obj.linkFunc ? "linkFunc" : "link";
      }
      else if ( obj.hasOwnProperty( "multiFunc" ) )
      {
        changeType = "multi";
      }
      else
      {
        value = obj;
      }

      registry.push( [ key, obj, changeType, [], value ] );
    });

    // second pass generates dependency
    for ( var k = registry.length; k --; )
    {
      lookup[ registry[ k ][ 0 ] ] = k;
    }

    for ( var k = registry.length; k --; )
    {
      if ( registry[ k ][ 2 ] === "linkFunc" || registry[ k ][ 2 ] === "link" )
      {
        var dependency = [];
        var names = [ registry[ k ][ 1 ].names ];

        while ( names.length > 0 )
        {
          var currentNames = names.pop();
          dependency = dependency.concat( currentNames );
          for ( var n = currentNames.length; n --; )
          {
            if ( registry[ 0 + lookup[ "" + currentNames[ n ] ] ][ 2 ] === "linkFunc" || registry[ 0 + lookup[ "" + currentNames[ n ] ] ][ 2 ] === "link" )
            {
              names.push( registry[ 0 + lookup[ "" + currentNames[ n ] ] ][ 1 ].names );
            }
          }
        }

        registry[ k ][ 3 ] = dependency;
      }
    }

    // sort by dependency
    registry.sort( function( a, b )
    {
      if ( a[ 3 ].indexOf( b[ 0 ] ) >= 0 )
      {
        return 1;
      }
      if ( b[ 3 ].indexOf( a[ 0 ] ) >= 0 )
      {
        return -1;
      }
      if ( a[ 2 ] && !b[ 2 ] )
      {
        return 1;
      }
      else if ( b[ 2 ] && !a[ 2 ] )
      {
        return -1;
      }
      return 0;
    });

    for ( var k = registry.length; k --; )
    {
      lookup[ registry[ k ][ 0 ] ] = k;
    }
    
    return
    {
      
      /* Function: update
       * Updates the object to fit the timeline.
       *
       * time
       *   A Number, the current time (in milliseconds) on the Composition's timeline.
       * scope
       *   [default] object
       *   An Object, scope under which the binded functions are called.
       */
      update : function( time, scope )
      {
        for ( var i = 0; i < registry.length; i ++ )
        {
          switch ( registry[ i ][ 2 ] )
          {
            case "func" :
              registry[ i ][ 4 ] = registry[ i ][ 1 ].apply( scope || params.object, [ time ] );
              break;
            case "link" :
              // should be computed already
              registry[ i ][ 4 ] = registry[ 0 + lookup[ "" + registry[ i ][ 3 ][ 0 ] ] ][ 4 ];
              break;
            case "linkFunc" :
              var funcArgs = [];
              var names = registry[ i ][ 3 ];

              for ( var a = 0; a < names.length; a ++ )
              {
                funcArgs.push( registry[ 0 + lookup[ "" + names[ a ] ] ][ 4 ] );
              }

              funcArgs.push( time );

              registry[ i ][ 4 ] = registry[ i ][ 1 ].linkFunc.apply( scope || params.object, funcArgs );
              break;
            case "multi" :
              registry[ i ][ 4 ] = registry[ i ][ 1 ].multiFunc.apply( scope || params.object, [ time ] );
              var names = registry[ i ][ 1 ].names;

              for ( var a = 0; a < names.length; a ++ )
              {
                setParam( params.object, names[ a ], registry[ i ][ 4 ][ a ] );
              }
              break;
          }
          setParam( params.object, registry[ i ][ 0 ], registry[ i ][ 4 ] );
        }
      }
    };
  };

  /* Class: Binder.Link
   * Represents a link between different properties.
   *
   * name
   *   The name of the property to link.
   * names
   *   [default] [ name ]
   *   Array of strings. Overrides name if specified.
   * linkFunc
   *   [default] null
   *   A Function accepting input & time from binder or null indicating copy.
   */
  binderClass.Link = function( params )
  {
    return
    {
      names : params.names || [ params.name ],
      linkFunc : params.linkFunc || null
    };
  };

  /* Class: Binder.Multi
   *
   * names
   *   Array of strings.
   * func
   *   A Function returning an array of values corresponding to names.
   */
  binderClass.Multi = function( params )
  {
    return
    {
      names : params.names,
      multiFunc : params.func
    };
  };
  
  return binderClass;
}();
