// {{Depend : Akari}} //
// {{Depend : Akari.Utilities}} //
// {{Depend : Akari.Display}} //
// {{Depend : Akari.Display.Declarative}} //

/* Namespace: Akari.Display.Text
 * Classes for displaying vector text.
 */
Akari.Display.Text = {};

/* Class: DynamicVectorTextLayer
 * A type of layer specialized to display basic dynamic vector text (huge sizes over 200px or exotic fonts).
 *
 * dictionary
 *   An Object containing Frames for possible glyphs.
 *   Glyphs should be provided by user, be anchored at top-left and be of 200px in size.
 * textProperties
 *   [default] { horizontalAlign : "left", verticalAlign : "top", letterSpacing : 20, fixedWidth : false, fontSize : 200, lineHeight : 240, text : "" }
 *   An Object, containing values or Bindings for vector text properties: horizontalAlign, verticalAlign, fontSize, letterSpacing, lineHeight, text.
 *   If fixedWidth is true, spacing between characters will always be fontSize + letterSpacing or ( fontSize / 2 ) + letterSpacing depending on which the actual width is nearer to.
 * inPoint
 *   A Number, the time (in milliseconds) at which the layers enters.
 * outPoint
 *   A Number, the time (in milliseconds) at which the layers exits.
 * properties
 *   [default] {}
 *   An Object, containing values or Bindings for each AS3 property.
 */
Akari.Display.Text.DynamicVectorTextLayer = function( params )
{
  // Create Sprites for alignment
  var linesContainer = Akari.Display.Sprite();
  var alignmentContainer = Akari.Display.Sprite();
  alignmentContainer.addChild( linesContainer );
  
  // Create objects for binding and change detection, due to lack of property getter / setters.
  var lastTextProperties = { horizontalAlign : "left", verticalAlign : "top", letterSpacing : 20, fixedWidth : false, fontSize : 200, lineHeight : 240, text : "" };
  
  var textProperties = { horizontalAlign : "left", verticalAlign : "top", letterSpacing : 20, fixedWidth : false, fontSize : 200, lineHeight : 240, text : "" };
  var textPropertiesBinder = Akari.Utilities.Binder({ object : textProperties, properties : params.textProperties || {} });
  
  // Create a Layer to contain text.
  var layer = Akari.Display.Layer(
  {
    source : alignmentContainer,
    inPoint : params.inPoint,
    outPoint : params.outPoint,
    properties : params.properties
  });
  
  // Simulate inheritance by making a backup of update function.
  var baseUpdate = Akari.Utilities.Factory.clone( layer.update, layer );
  
  // Declare new update
  layer.update = function( time )
  {
    baseUpdate( time );
      
    // Update binder and check if anything changes
    textPropertiesBinder.update( time, layer.getBinderScope() );
    
    var needGlyphReset = ( textProperties.text != lastTextProperties.text );
    var needGlyphAdjust = needGlyphReset || ( textProperties.letterSpacing != lastTextProperties.letterSpacing ) || ( textProperties.fontSize != lastTextProperties.fontSize );
    var needAlignmentAdjust = needGlyphAdjust || ( textProperties.horizontalAlign != lastTextProperties.horizontalAlign ) || ( textProperties.verticalAlign != lastTextProperties.verticalAlign ) || ( textProperties.lineHeight != lastTextProperties.lineHeight );
    
    if ( needAlignmentAdjust ) lastTextProperties = Akari.Utilities.Factory.clone( textProperties );
    
    // Reset Glyphs if needed (most expensive)
    if ( needGlyphReset )
    {
      // Remove all children from linesContainer
      while ( linesContainer.numChildren > 0 ) linesContainer.removeChildAt( 0 );
      
      // Split text into lines to process
      var lines = textProperties.text.split( "\n" );
      
      for ( var numLine = 0; numLine < lines.length; numLine ++ )
      {
        // For each line create a new Sprite to contain glyphs
        var lineSprite = Sprite();
        
        for ( var numChar = 0; numChar < lines[ numLine ].length; numChar ++ )
        {
          // Create glyphs and put them in current line. Position does not matter since it will be corrected afterwards.
          lineSprite.addChild( Akari.Display.Declarative.DeclarativeShape( params.dictionary[ lines[ numLine ].charAt( numChar ) ] ) );
        }
        
        // Add new Sprite to linesContainer
        linesContainer.addChild( lineSprite );
      }
    }
    
    // Adjust glyphs if needed
    if ( needGlyphAdjust )
    {
      for ( var numLine = 0; numLine < linesContainer.numChildren; numLine ++ )
      {
        var lineSprite = linesContainer.getChildAt( numLine );
        var accumulativeX = 0;
        
        for ( var numChar = 0; numChar < lineSprite.numChildren; numChar ++ )
        {
          var glyph = lineSprite.getChildAt( numChar );
          
          // Set letter spacing and size
          glyph.x = accumulativeX;
          glyph.scaleX = glyph.scaleY = textProperties.fontSize / 200.0;
          
          if ( textProperties.fixedWidth )
          {
            // Text is fixed width, transform the width
            var nwFactor = Math.round( glyph.width / textProperties.fontSize );
            accumulativeX += textProperties.fontSize * ( nwFactor / 2 + 0.5 ) + textProperties.letterSpacing;
          }
          else
          {
            // Always use actual width
            accumulativeX += glyph.width + textProperties.letterSpacing;
          }
        }
      }
    }
    
    // Adjust alignment if needed
    if ( needAlignmentAdjust )
    {
      for ( var numLine = 0; numLine < linesContainer.numChildren; numLine ++ )
      {
        var lineSprite = linesContainer.getChildAt( numLine );
        
        // Set line height and alignment
        switch ( textProperties.horizontalAlign )
        {
          case "left":
            lineSprite.x = 0;
            break;
          case "right":
            lineSprite.x = - lineSprite.width;
            break;
          case "center":
            lineSprite.x = - lineSprite.width / 2;
            break;
        }
        lineSprite.y = numLine * textProperties.lineHeight;
      }
      
      // Set vertical alignment
      switch ( textProperties.verticalAlign )
      {
        case "top":
          linesContainer.y = 0;
          break;
        case "bottom":
          linesContainer.y = - linesContainer.height;
          break;
        case "center":
          linesContainer.y = - linesContainer.height / 2;
          break;
      }
    }
  };
    
  /* Function: clone
   * Custom clone function for binder to work.
   */
  layer.clone = function()
  {
    return Akari.Display.Text.DynamicVectorTextLayer( Akari.Utilities.Factory.clone( params ) );
  };
  
  // Update Layer for a first time to prevent flashing
  layer.update( params.inPoint );
  
  return layer;
};